\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{unicode-helper}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{microtype}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage[pdftex]{hyperref}
\usepackage{cleveref}

\newcommand{\titlevar}{The Sesame Specification}
\newcommand{\authorvar}{Jonathan Busch \& Günthner}
\newcommand{\datevar}{Summer 25}
\title{\titlevar}
\author{\authorvar}
\date{\datevar}
\hypersetup{
	pdftitle=\titlevar,
	pdfauthor=\authorvar,
	pdfcreationdate=\datevar,
}
\setlength{\parindent}{0pt}

\newtheorem{remark}{Remark}

\newcommand{\mas}{Mark-and-Sweep}
\newcommand{\PREV}[1]{P({#1})}
\newcommand{\NEXT}[1]{N({#1})}
\newcommand{\reachable}[1]{\text{reach}({#1})}
\newcommand{\rootset}{\text{root}}
\newcommand{\code}[1]{\tcbox[on line, left=0mm,top=0.7mm,right=0mm,bottom=0.7mm]{\texttt{#1}}}

\begin{document}
	\maketitle

	\section{Introduction}

	This document specifies the Bert language, associated tools and the runtime implementation of it.

	\section{The Language}

	The specification of syntax and of semantics go here.

	\section{The Implementation}


	\subsection{Gabage Collection}

	On the language level the garbage collection will resemble the popular \mas schemes used in f.e. Java. However in the implementation and in the code emitted by the compiler there is a lot of optimization possibe.

	\subsubsection{Avoiding \mas}

	The difficulty in garbage collection lies in finding cycles in the reference graph. Now parts of this process can be done at compile time on the type graph. For this, some formalism will prove useful: Denote the reference digraph (w. self-reference) by $(O,r)$ and the type digraph by $(T, r')$. Now the canonical projection map $π$ will be a graph homomorphism:
	\begin{equation*}
		π: O → T
	\end{equation*}
	This sends and object of type $t$ to the type $t$ and an arrow (alt. a reference) $(a,b)$ with objects of types $t_a,t_b$ to $(t_a, t_b)$.

	\medskip

	Now we will introduce standared graph operations: \\
	For $oϵO$, $\PREV o$ ($\NEXT o$) denotes the previous (next) elements for $o$. Formally:
	\begin{equation*}
		\begin{split}
			\PREV o &\coloneq \set{x ϵ O | (x,o) ϵ r} \\
			\NEXT o &\coloneq \set{x ϵ O | (o,x) ϵ r}
		\end{split}
	\end{equation*}

	For reachability we must define the root set, the set of all elements which are by definition reachable, for example if they are stored in a global variable (not applicable for Bert) or if they represent a stack context.

	\begin{remark}
		Why do we have objects representing stack contexts? They ease the fomalisation of garbage collection.
	\end{remark}

	This set we will denote by $\rootset$

	\subsubsection{Something something \mas}

	This will either specify the implementation of \mas or an aternative scheme.

	\section{Tools}

	Here we specify usage of the \code{ernie} command and others.
\end{document}
